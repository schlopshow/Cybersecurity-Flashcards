What is GraphQL and how does it differ from REST APIs?|GraphQL is a query language for web APIs that enables clients to fetch required data through a simple syntax. Unlike REST APIs that use multiple endpoints, GraphQL typically uses a single endpoint to handle all queries, making it more efficient in resource and request usage.
Where is the GraphQL endpoint typically located?|The GraphQL endpoint is most commonly located at /graphql, /api/graphql, or similar paths.
What is the basic structure of a GraphQL query?|GraphQL queries select fields of objects where each object is of a specific type. The query is structured with the query name at the root, followed by the fields to retrieve enclosed in curly braces.
What is GraphQL introspection?|Introspection is a GraphQL feature that enables users to query the API about the structure of the backend system, allowing discovery of all supported queries, types, and fields by querying the __schema field.
What tool can be used to identify the GraphQL engine?|graphw00f is a fingerprinting tool that sends various GraphQL queries including malformed ones to determine the GraphQL engine by analyzing backend behavior and error messages.
What is GraphQL sub-querying?|Sub-querying enables a query to obtain details from an object that references another object, allowing nested data retrieval in a single query.
How can IDOR vulnerabilities manifest in GraphQL?|IDOR vulnerabilities occur when GraphQL queries lack proper authorization checks, allowing users to access other users' data by simply changing parameters like usernames or IDs in the query.
What types of injection attacks can affect GraphQL APIs?|GraphQL APIs can be vulnerable to SQL injection, Cross-Site Scripting (XSS), and command injection if user input from query arguments is not properly sanitized.
How can SQL injection be identified in GraphQL queries?|SQL injection can be identified by injecting SQL payloads in query arguments. Signs include SQL errors in responses, queries returning unexpected results, or queries still functioning with SQL comment syntax.
Where can XSS vulnerabilities occur in GraphQL?|XSS vulnerabilities can occur when GraphQL responses are inserted into HTML without sanitization, or when invalid arguments containing XSS payloads are reflected in error messages without proper encoding.
What is a GraphQL DoS attack based on query depth?|A DoS attack exploits circular relationships between object types (like UserObject and PostObject) to create deeply nested queries that result in exponentially large responses, consuming significant server resources.
What is GraphQL batching?|Batching in GraphQL allows executing multiple queries in a single HTTP request by supplying queries as a JSON array, which can be exploited to bypass rate limits in brute-force attacks.
What are GraphQL mutations?|Mutations are GraphQL queries that modify server data, used to create new objects, update existing objects, or delete existing objects.
How can mutations lead to privilege escalation?|If mutations don't properly validate input parameters like user roles, attackers can specify privileged roles when creating accounts, potentially gaining unauthorized administrative access.
What security tool performs automated security audits on GraphQL APIs?|GraphQL-Cop is a security audit tool that executes multiple basic security configuration checks and lists identified issues as a baseline for further manual testing.
What is the InQL Burp extension used for?|InQL is a Burp extension that simplifies GraphQL testing by adding GraphQL tabs for easier query modification, generating introspection information, and creating query templates automatically.
What is the primary mitigation for information disclosure in GraphQL?|Disable introspection queries in production environments, prevent verbose error messages, and ensure no sensitive information is exposed through the API schema.
How should injection attacks be prevented in GraphQL?|Implement proper input validation treating all user-supplied data as untrusted, use allowlists over denylists, and sanitize all query arguments before processing.
What limits should be implemented to prevent GraphQL DoS attacks?|Implement query depth limits, maximum query size limits, rate limits on the endpoint, and disable batching if not required. If batching is necessary, strictly limit query depth.
What authorization principle should GraphQL APIs follow?|Follow the principle of least privileges with strict access control measures, require authentication before allowing endpoint access, and implement authorization checks on all queries and mutations.
What is graphiql and why is it significant for security testing?|Graphiql is a GraphQL interface that can be accessed directly in a web browser, allowing convenient direct query submission without worrying about JSON syntax, making enumeration and testing easier for attackers.
What information can be obtained from the GraphQL Threat Matrix?|The GraphQL Threat Matrix provides detailed information about specific GraphQL engines including security considerations like whether field suggestions and introspection are enabled by default, and what security features are supported.
Why is GraphQL typically more efficient than REST APIs?|GraphQL allows clients to request exactly the data they need in a single query to one endpoint, rather than making multiple requests to different REST endpoints and receiving potentially unnecessary data.
What is the purpose of GraphQL Voyager?|GraphQL Voyager is a tool that visualizes the GraphQL schema, allowing users to explore all supported queries, types, and fields in a graphical interface after providing introspection query results.
What does the GraphQL connection type require when querying?|When querying a connection type, you must specify the edges and node fields to obtain a reference to the corresponding object.
How can you identify if a GraphQL query requires arguments?|Send the query without arguments and analyze the response. If arguments are required, the error message will specify the name and type of the required argument.
What is the significance of field ordering in GraphQL SQL injection?|The order of fields in a GraphQL query corresponds to column positions in the database. For UNION-based injection, the number of columns in the payload must match the number of fields in the object being queried.
Why might SQL injection payloads need to use GROUP_CONCAT?|Since GraphQL queries typically only return the first row, GROUP_CONCAT allows exfiltration of multiple rows of data concatenated into a single result.
What is the relationship between UserObject fields and database columns?|UserObject fields correspond directly to columns in the database table, which is important for constructing UNION-based SQL injection payloads with the correct number of columns.
How can circular relationships in GraphQL schema be exploited?|Circular relationships between objects (like User having Posts and Posts having Author) can be queried recursively to create exponentially growing responses that consume excessive server resources.
What is alias overloading in GraphQL?|Alias overloading is a DoS technique where attackers use many aliases (100+) in a single query, which can overwhelm the server and cause denial of service.
What is directive overloading in GraphQL?|Directive overloading involves using multiple duplicated directives in a query, which can lead to denial of service by consuming excessive server resources during query processing.
What is field duplication as a DoS vector?|Field duplication allows queries with hundreds of the same repeated field, which can cause denial of service by creating unnecessarily large responses and computation overhead.
Why are field suggestions considered an information leakage risk?|Field suggestions can reveal available field names and schema structure to attackers, helping them understand the API's data model even when full introspection is disabled.
What CSRF risks exist with GraphQL GET method support?|When GraphQL accepts queries via GET method, it becomes vulnerable to Cross-Site Request Forgery attacks since GET requests can be triggered through simple links or image tags.
Why is POST-based URL-encoded query support a security concern?|Accepting non-JSON queries over POST can enable CSRF attacks because URL-encoded forms can be submitted cross-origin without triggering CORS preflight checks.
What is the security implication of enabled GraphQL IDEs in production?|GraphQL IDEs like GraphiQL or Playground in production environments provide easy interfaces for attackers to explore and test the API, increasing information leakage risks.
How does batching amplify brute-force attacks?|Batching allows multiple login attempts in a single HTTP request, so a rate limit of 5 requests/second with 1000 queries per batch effectively allows 5000 attempts/second.
What principle should guide GraphQL mutation authorization?|All mutations must implement proper authorization checks to ensure users can only perform actions they're authorized to, following the principle of least privilege.
Why should introspection be disabled in production GraphQL APIs?|Introspection reveals the entire API schema including all queries, mutations, types, and fields, providing attackers with a complete map of potential attack vectors.
What is the risk of exposing role parameters in registration mutations?|If role parameters are exposed without validation, attackers can register accounts with elevated privileges like admin roles, bypassing normal privilege constraints.
How should GraphQL error messages be configured for security?|Error messages should be generic and non-verbose to prevent information disclosure. Detailed error messages including SQL queries or stack traces should never be shown to users.
What is the security benefit of query depth limiting?|Query depth limits prevent attackers from creating deeply nested circular queries that result in exponentially large responses and resource exhaustion.
Why should allowlists be preferred over denylists for input validation?|Allowlists explicitly define what is permitted, which is more secure than denylists that try to block known bad inputs but may miss new attack patterns.
What authentication requirement is recommended for GraphQL endpoints?|GraphQL endpoints should only be accessible after successful authentication whenever possible, preventing unauthorized users from exploring or exploiting the API.
How do GraphQL arguments function in queries?|Arguments allow filtering or parameterizing queries, similar to function parameters, enabling specific data retrieval like querying a user by username or a post by ID.
What makes UNION-based SQL injection possible in GraphQL?|If user input in query arguments is concatenated into SQL queries without proper sanitization, attackers can inject UNION statements to retrieve arbitrary database data.
Why is the information_schema database significant in SQL injection?|The information_schema database contains metadata about all databases, tables, and columns, allowing attackers to map the entire database structure for targeted data exfiltration.
What role does GraphQL type system play in security?|The type system defines what data structures exist and their fields, but without proper authorization checks, this structure can be exploited to access unauthorized data.
How can mutations be discovered through introspection?|Mutations can be discovered by querying the __schema mutationType field, which reveals all available mutations, their names, and required input parameters.
What is the security significance of MD5 password hashing?|MD5 is a weak hashing algorithm that's vulnerable to rainbow table attacks and should not be used for password storage in production systems.
Why might different queries have different SQL injection vulnerabilities?|Different queries may use different SQL query construction methods or sanitization approaches, so each query argument should be tested independently for injection vulnerabilities.
What is the purpose of the RegisterUserInput type?|RegisterUserInput is an input type that defines the structure and fields required for user registration mutations, specifying what data must be provided.
How does GraphQL handle nested object relationships?|GraphQL allows querying nested objects through field references, enabling retrieval of related data in a single query by traversing object relationships.
What security consideration exists with GraphQL's single endpoint design?|While efficient, the single endpoint design means all security controls must be implemented at that one point, and misconfiguration affects the entire API.
Why should query size limits be implemented?|Query size limits prevent attackers from sending extremely large queries that could consume excessive bandwidth, memory, or processing time.
What is the risk of exposing password fields in query results?|If password fields are queryable without proper authorization, attackers can retrieve password hashes for any user through IDOR vulnerabilities, enabling offline cracking.
How does GraphQL handle multiple queries in sequence?|Traditional sequential queries require multiple HTTP requests, but batching allows multiple queries in one request, improving efficiency but potentially enabling abuse.
What makes GraphQL error-based SQL injection detection possible?|When SQL errors are returned in GraphQL responses, they reveal database structure and query syntax, confirming SQL injection vulnerabilities and aiding exploitation.
Why is testing each argument separately important?|Each argument may have different input validation or sanitization, so thorough testing requires checking every argument in every query and mutation for vulnerabilities.
